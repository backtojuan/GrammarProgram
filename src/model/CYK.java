//__________________________________________________________________________________________________________________________________v
package model;

import java.util.HashSet;

//__________________________________________________________________________________________________________________________________
/**
 * This class manages the necessary attributes and methods to run CYK algorithm over a given context-free grammar.
 * @author Juan José Valencia Jaramillo
 * @version 1.0
 *
 */
public class CYK {
	private String string;	
	private HashSet<String>[][] CYKTable;
//__________________________________________________________________________________________________________________________________	
	/**
	 * <b>CYK constructor</b>
	 * @param string the string input to validate
	 */
	@SuppressWarnings("unchecked")
	public CYK(String string) {
		this.string = string;
		CYKTable = new HashSet[string.length()][string.length()];
	}
//__________________________________________________________________________________________________________________________________
	/**
	 * This method returns the string input 
	 * <b>Pre:</b> the cyk exists
	 * @return the string input
	 */
	public String getStringInput() {
		return string;
	}
//__________________________________________________________________________________________________________________________________
	/**
	 * This method returns the cyktable filled once the cyk algorithm is run
	 * <b>Pre:</b> the cyk exists
	 * @return the cyk table
	 */
	@SuppressWarnings("rawtypes")
	public HashSet[][] getCYKTable(){
		return CYKTable;
	}	
//__________________________________________________________________________________________________________________________________				
	/**
	 * This method runs the cyk algorithm to check if a string input is generated by a given context-free grammar
	 * <b>Pos:</b> The cyk validates wether the string input is generated or not by the given grammar.
	 * @param string the string input
	 * @param grammar the grammar in CNF
	 * @return a boolean value
	 */
	public boolean CYKAlgorithm(String string, Grammar grammar) {
		boolean confirmation = false;
		if(string.equalsIgnoreCase(Grammar.LAMBDA)) {  
			//if the input string is "lambda" the only production it needs to be checked it's 'S'
			return grammar.getProductionRules().get(grammar.getInitialSymbol()).contains(string);
		}
		int n = string.length();
		String[] terminals = string.split("");
		for(int i=0; i < n; i++) {
			CYKTable[i][0] = new HashSet<>();
			isInGrammar(grammar, terminals[i], i, 0);		
		}
		for(int j=1;j<n;j++) {
			for(int i=0;i<n-j;i++) {
				CYKTable[i][j] = new HashSet<>();
				for (int k = 0; k <= j - 1; k++) {
					 HashSet<String> set1 = CYKTable[i][k]; 
	                 HashSet<String> set2 = CYKTable[i + k + 1][j - k - 1];
	                 String[] prods = cartesianProduct(set1, set2);
	                 for (String body : prods) { // Xij := A in V / A --> BC is a production of G
	                        isInGrammar(grammar, body, i, j);
	                 }
                }
			}
		}
		if(CYKTable[0][n - 1].contains(grammar.getInitialSymbol())) {
			confirmation = true;
		}
		return confirmation;
	}
//__________________________________________________________________________________________________________________________________
	/**
	 * This method allows to check if a single terminal is generated by some production rule
	 * <b>Pre:</b> The grammar exists
	 * <b>Pos:</b> The validation confirms wether the terminal is produced by this grammar or not
	 * @param head the head of the production rule
	 * @param terminal the terminal of the string
	 * @return a boolean value 
	 */
	public void isInGrammar(Grammar grammar, String w, int i, int j) {			
		for(String head : grammar.getSymbols()) {
			for(String body : grammar.getProductionRules().get(head)) {
				if(body.equals(w)) {
					CYKTable[i][j].add(head);
				}
			}
		}					
	}
	
//__________________________________________________________________________________________________________________________________
	/**
	 * This method allows to make the cartesian product between two sets to check if the union of this bodies elements if in the grammar
	 * @param set1 the first set 
	 * @param set2 the other set
	 * @return an String array with the union of the elements
	 */
	private String[] cartesianProduct(HashSet<String> set1, HashSet<String> set2) {
        String[] cartesianProductResult = new String[set1.size() * set2.size()];
        int i = 0;
        for (String element1 : set1) {
            for (String element2 : set2) {
                cartesianProductResult[i] = element1 + element2;
                i++;
            }
        }
        return cartesianProductResult;
}
//__________________________________________________________________________________________________________________________________
	/**
	 * This method prints the resultant table after running the cyk algorithm
	 * @return the cyk table
	 */
	public String printTable() {
		String table = "";		
		table += "--------------------------------------------------------------------------------------------------------------------------" + "\n";
		for(int i=0;i<CYKTable.length;i++) {		
			table += "" + string.charAt(i) + "        ";
			for(int j=0;j<CYKTable[i].length;j++) {
				if(CYKTable[i][j]!=null) {
					table += "" + CYKTable[i][j] + "                    ";					
				}
				else {
					table += "--";
				}
				if(j+1==string.length()) {
					table += "\n";
				}
			}
		}		
		table += "--------------------------------------------------------------------------------------------------------------------------";
		return table;
	}
//__________________________________________________________________________________________________________________________________
}